package config

import spinal.core._
import spinal.lib._

import scala.math._


/**
 * all configurations parameters are listed here
 * which are just copy from https://github.com/soDLA-publishment/soDLA
 */

class project_spec extends nv_small_config
{
  val NVDLA_FEATURE_DATA_TYPE_INT8 = FEATURE_DATA_TYPE_INT8
  val NVDLA_BPE = 8
  val NVDLA_WEIGHT_DATA_TYPE_INT8 = WEIGHT_DATA_TYPE_INT8
  val NVDLA_WEIGHT_COMPRESSION_ENABLE = WEIGHT_COMPRESSION_ENABLE
  val NVDLA_WINOGRAD_ENABLE = WINOGRAD_ENABLE
  val NVDLA_BATCH_ENABLE = BATCH_ENABLE
  val NVDLA_SECONDARY_MEMIF_ENABLE = SECONDARY_MEMIF_ENABLE
  val NVDLA_SDP_LUT_ENABLE = SDP_LUT_ENABLE
  val NVDLA_SDP_BS_ENABLE = SDP_BS_ENABLE
  val NVDLA_SDP_BN_ENABLE = SDP_BN_ENABLE
  val NVDLA_SDP_EW_ENABLE = SDP_EW_ENABLE
  val NVDLA_BDMA_ENABLE = BDMA_ENABLE
  val NVDLA_RUBIK_ENABLE = RUBIK_ENABLE
  val NVDLA_RUBIK_CONTRACT_ENABLE = RUBIK_CONTRACT_ENABLE
  val NVDLA_RUBIK_RESHAPE_ENABLE = RUBIK_RESHAPE_ENABLE
  val NVDLA_PDP_ENABLE = PDP_ENABLE
  val NVDLA_CDP_ENABLE = CDP_ENABLE
  val NVDLA_RETIMING_ENABLE = RETIMING_ENABLE
  val NVDLA_MAC_ATOMIC_C_SIZE = MAC_ATOMIC_C_SIZE
  val NVDLA_MAC_ATOMIC_K_SIZE = MAC_ATOMIC_K_SIZE
  val NVDLA_MEMORY_ATOMIC_SIZE = MEMORY_ATOMIC_SIZE
  val NVDLA_MAX_BATCH_SIZE = MAX_BATCH_SIZE
  val NVDLA_CBUF_BANK_NUMBER = CBUF_BANK_NUMBER
  val NVDLA_CBUF_BANK_WIDTH = CBUF_BANK_WIDTH
  val NVDLA_CBUF_BANK_DEPTH = CBUF_BANK_DEPTH
  val NVDLA_SDP_BS_THROUGHPUT = if(SDP_BS_ENABLE) SDP_BS_THROUGHPUT else 0
  val NVDLA_SDP_BN_THROUGHPUT = if(SDP_BN_ENABLE) SDP_BN_THROUGHPUT else 0
  val NVDLA_SDP_EW_THROUGHPUT = if(SDP_EW_ENABLE) SDP_EW_THROUGHPUT else 0
  val NVDLA_SDP_EW_THROUGHPUT_LOG2 = if(SDP_EW_ENABLE) log2Up(NVDLA_SDP_EW_THROUGHPUT) else 0
  val NVDLA_SDP_MAX_THROUGHPUT = Array(NVDLA_SDP_EW_THROUGHPUT, NVDLA_SDP_BN_THROUGHPUT,NVDLA_SDP_BS_THROUGHPUT).reduceLeft(_ max _)
  val NVDLA_SDP2PDP_WIDTH = NVDLA_SDP_MAX_THROUGHPUT * NVDLA_BPE
  val NVDLA_PDP_THROUGHPUT = PDP_THROUGHPUT
  val NVDLA_CDP_THROUGHPUT = CDP_THROUGHPUT
  val NVDLA_PRIMARY_MEMIF_LATENCY = PRIMARY_MEMIF_LATENCY
  val NVDLA_SECONDARY_MEMIF_LATENCY = SECONDARY_MEMIF_LATENCY
  val NVDLA_PRIMARY_MEMIF_MAX_BURST_LENGTH = PRIMARY_MEMIF_MAX_BURST_LENGTH
  val NVDLA_PRIMARY_MEMIF_WIDTH = PRIMARY_MEMIF_WIDTH
  val NVDLA_SECONDARY_MEMIF_MAX_BURST_LENGTH = SECONDARY_MEMIF_MAX_BURST_LENGTH
  val NVDLA_SECONDARY_MEMIF_WIDTH = SECONDARY_MEMIF_WIDTH
  val NVDLA_MEM_ADDRESS_WIDTH = MEM_ADDRESS_WIDTH
  val NVDLA_MEMIF_WIDTH = if(SECONDARY_MEMIF_ENABLE)
    Array(NVDLA_PRIMARY_MEMIF_WIDTH, NVDLA_SECONDARY_MEMIF_WIDTH, NVDLA_MEMORY_ATOMIC_SIZE*NVDLA_BPE).reduceLeft(_ max _)
  else
    max(NVDLA_PRIMARY_MEMIF_WIDTH, NVDLA_MEMORY_ATOMIC_SIZE*NVDLA_BPE)
  val NVDLA_DMA_RD_SIZE = 15
  val NVDLA_DMA_WR_SIZE = 13
  val NVDLA_DMA_MASK_BIT = NVDLA_MEMIF_WIDTH / NVDLA_BPE / NVDLA_MEMORY_ATOMIC_SIZE
  val NVDLA_DMA_RD_RSP = NVDLA_MEMIF_WIDTH + NVDLA_DMA_MASK_BIT
  val NVDLA_DMA_WR_REQ = NVDLA_MEMIF_WIDTH + NVDLA_DMA_MASK_BIT + 1
  val NVDLA_DMA_WR_CMD = NVDLA_MEM_ADDRESS_WIDTH + NVDLA_DMA_WR_SIZE +1
  val NVDLA_DMA_RD_REQ = NVDLA_MEM_ADDRESS_WIDTH + NVDLA_DMA_RD_SIZE
  val NVDLA_MEMORY_ATOMIC_LOG2 = log2Up(NVDLA_MEMORY_ATOMIC_SIZE)
  val NVDLA_PRIMARY_MEMIF_WIDTH_LOG2 = log2Up(NVDLA_PRIMARY_MEMIF_WIDTH/8)
  val NVDLA_SECONDARY_MEMIF_WIDTH_LOG2 = if(SECONDARY_MEMIF_ENABLE)
    log2Up(NVDLA_SECONDARY_MEMIF_WIDTH/8)
  else
    None
  val NVDLA_MEMORY_ATOMIC_WIDTH =  NVDLA_MEMORY_ATOMIC_SIZE*NVDLA_BPE
  val NVDLA_MCIF_BURST_SIZE = NVDLA_PRIMARY_MEMIF_MAX_BURST_LENGTH*NVDLA_DMA_MASK_BIT
  val NVDLA_MCIF_BURST_SIZE_LOG2 = log2Up(NVDLA_MCIF_BURST_SIZE)
  val DESIGNWARE_NOEXIST = true
  val PDP_SINGLE_LBUF_WIDTH = 16*NVDLA_MEMORY_ATOMIC_SIZE/NVDLA_PDP_THROUGHPUT
  val PDP_SINGLE_LBUF_DEPTH = NVDLA_PDP_THROUGHPUT*(NVDLA_BPE+6)

  val NVDLA_VMOD_PRIMARY_BANDWIDTH = NVDLA_PRIMARY_MEMIF_WIDTH/NVDLA_BPE/4
  val NVDLA_VMOD_SDP_MRDMA_OUTPUT_THROUGHPUT = NVDLA_SDP_MAX_THROUGHPUT
  val NVDLA_VMOD_SDP_BRDMA_OUTPUT_THROUGHPUT = 4*NVDLA_SDP_BS_THROUGHPUT
  val NVDLA_VMOD_SDP_NRDMA_OUTPUT_THROUGHPUT = 4*NVDLA_SDP_BN_THROUGHPUT
  val NVDLA_VMOD_SDP_ERDMA_OUTPUT_THROUGHPUT = 4*NVDLA_SDP_EW_THROUGHPUT
  val NVDLA_VMOD_CDP_RDMA_OUTPUT_THROUGHPUT_USE = min(NVDLA_CDP_THROUGHPUT, NVDLA_VMOD_PRIMARY_BANDWIDTH)
  val NVDLA_VMOD_PDP_RDMA_OUTPUT_THROUGHPUT_USE = min(NVDLA_PDP_THROUGHPUT, NVDLA_VMOD_PRIMARY_BANDWIDTH)
  val NVDLA_VMOD_SDP_MRDMA_OUTPUT_THROUGHPUT_USE = min(NVDLA_VMOD_SDP_MRDMA_OUTPUT_THROUGHPUT, NVDLA_VMOD_PRIMARY_BANDWIDTH)
  val NVDLA_VMOD_SDP_BRDMA_OUTPUT_THROUGHPUT_USE = min(NVDLA_VMOD_SDP_BRDMA_OUTPUT_THROUGHPUT, NVDLA_VMOD_PRIMARY_BANDWIDTH)
  val NVDLA_VMOD_SDP_NRDMA_OUTPUT_THROUGHPUT_USE = min(NVDLA_VMOD_SDP_NRDMA_OUTPUT_THROUGHPUT, NVDLA_VMOD_PRIMARY_BANDWIDTH)
  val NVDLA_VMOD_SDP_ERDMA_OUTPUT_THROUGHPUT_USE = min(NVDLA_VMOD_SDP_ERDMA_OUTPUT_THROUGHPUT, NVDLA_VMOD_PRIMARY_BANDWIDTH)
  val NVDLA_VMOD_CDP_RDMA_LATENCY_FIFO_DEPTH  = max(4,ceil(NVDLA_PRIMARY_MEMIF_LATENCY*NVDLA_VMOD_CDP_RDMA_OUTPUT_THROUGHPUT_USE/(NVDLA_MEMIF_WIDTH/NVDLA_BPE))).toInt
  val NVDLA_VMOD_PDP_RDMA_LATENCY_FIFO_DEPTH  = max(4,ceil(NVDLA_PRIMARY_MEMIF_LATENCY*NVDLA_VMOD_PDP_RDMA_OUTPUT_THROUGHPUT_USE/(NVDLA_MEMIF_WIDTH/NVDLA_BPE))).toInt
  val NVDLA_VMOD_SDP_MRDMA_LATENCY_FIFO_DEPTH = max(4,ceil(NVDLA_PRIMARY_MEMIF_LATENCY*NVDLA_VMOD_SDP_MRDMA_OUTPUT_THROUGHPUT_USE/(NVDLA_MEMIF_WIDTH/NVDLA_BPE))).toInt
  val NVDLA_VMOD_SDP_BRDMA_LATENCY_FIFO_DEPTH = max(4,ceil(NVDLA_PRIMARY_MEMIF_LATENCY*NVDLA_VMOD_SDP_BRDMA_OUTPUT_THROUGHPUT_USE/(NVDLA_MEMIF_WIDTH/NVDLA_BPE))).toInt
  val NVDLA_VMOD_SDP_NRDMA_LATENCY_FIFO_DEPTH = max(4,ceil(NVDLA_PRIMARY_MEMIF_LATENCY*NVDLA_VMOD_SDP_NRDMA_OUTPUT_THROUGHPUT_USE/(NVDLA_MEMIF_WIDTH/NVDLA_BPE))).toInt
  val NVDLA_VMOD_SDP_ERDMA_LATENCY_FIFO_DEPTH = max(4,ceil(NVDLA_PRIMARY_MEMIF_LATENCY*NVDLA_VMOD_SDP_ERDMA_OUTPUT_THROUGHPUT_USE/(NVDLA_MEMIF_WIDTH/NVDLA_BPE))).toInt
  val NVDLA_VMOD_DMA_LAT_FIFO_DEPTH_MAX = 512

  val NVDLA_MAC_ATOMIC_C_SIZE_LOG2 = log2Up(NVDLA_MAC_ATOMIC_C_SIZE)
  val NVDLA_MAC_ATOMIC_K_SIZE_LOG2 = log2Up(NVDLA_MAC_ATOMIC_K_SIZE)
  val NVDLA_MAC_ATOMIC_K_SIZE_DIV2 = NVDLA_MAC_ATOMIC_K_SIZE/2
  val NVDLA_CBUF_BANK_NUMBER_LOG2 = log2Up(NVDLA_CBUF_BANK_NUMBER)
  val NVDLA_CBUF_BANK_WIDTH_LOG2 = log2Up(NVDLA_CBUF_BANK_WIDTH)
  val NVDLA_CBUF_BANK_DEPTH_LOG2 = log2Up(NVDLA_CBUF_BANK_DEPTH)
  val NVDLA_CBUF_DEPTH_LOG2 = log2Up(NVDLA_CBUF_BANK_NUMBER)+log2Up(NVDLA_CBUF_BANK_DEPTH)
  val NVDLA_CBUF_ENTRY_WIDTH = NVDLA_MAC_ATOMIC_C_SIZE*NVDLA_BPE
  val NVDLA_CBUF_WIDTH_LOG2 = log2Up(NVDLA_CBUF_ENTRY_WIDTH)
  val NVDLA_CBUF_WIDTH_MUL2_LOG2 = log2Up(NVDLA_CBUF_ENTRY_WIDTH)+1
  val NVDLA_BPE_LOG2 = log2Up(NVDLA_BPE)
  val NVDLA_MAC_RESULT_WIDTH = NVDLA_BPE*2+NVDLA_MAC_ATOMIC_C_SIZE_LOG2
  val NVDLA_CC_ATOMC_DIV_ATOMK = NVDLA_MAC_ATOMIC_C_SIZE/NVDLA_MAC_ATOMIC_K_SIZE
  val NVDLA_CACC_SDP_WIDTH = ((32*NVDLA_SDP_MAX_THROUGHPUT) +2)
  val NVDLA_CACC_SDP_SINGLE_THROUGHPUT = 32

  val NVDLA_CDMA_GRAIN_MAX_BIT = log2Up(NVDLA_CBUF_BANK_DEPTH*NVDLA_CBUF_BANK_WIDTH*(NVDLA_CBUF_BANK_NUMBER-1)/(NVDLA_MEMORY_ATOMIC_SIZE))

  val useFPGA = true

  var XSDB_SLV_DIS = true
  var FPGA = true
  var SYNTHESIS = true
  var VLIB_BYPASS_POWER_CG = true
  var NV_FPGA_SYSTEM = true
  var NV_FPGA_FIFOGEN = true
  var NV_FPGA_UNIT = true

  val REGINIT_DATA = true
  val UNIFY_CLOCK = true
  val CSB2REG_KEEP_BACKPRESSURE = false

  if(!useFPGA){
    XSDB_SLV_DIS = false
    FPGA = false
    SYNTHESIS = false
    VLIB_BYPASS_POWER_CG = false
    NV_FPGA_SYSTEM = false
    NV_FPGA_FIFOGEN = false
    NV_FPGA_UNIT = false
  }
}


class cmacConfiguration extends project_spec
{
  val CMAC_BPE = NVDLA_BPE //bits per element
  val CMAC_ATOMC = NVDLA_MAC_ATOMIC_C_SIZE
  val CMAC_ATOMK = NVDLA_MAC_ATOMIC_K_SIZE
  val CMAC_ATOMK_HALF  = CMAC_ATOMK/2
  val CMAC_INPUT_NUM = CMAC_ATOMC  //for one MAC_CELL
  val CMAC_SLCG_NUM = 3+CMAC_ATOMK_HALF
  val CMAC_RESULT_WIDTH = NVDLA_MAC_RESULT_WIDTH    //16b+log2(atomC)
  val CMAC_IN_RT_LATENCY = 2   //both for data&pd
  val CMAC_OUT_RT_LATENCY = 2   //both for data&pd
  val CMAC_OUT_RETIMING = 3   //only data
  val CMAC_ACTV_LATENCY = 2   //only data
  val CMAC_DATA_LATENCY = (CMAC_IN_RT_LATENCY+CMAC_OUT_RT_LATENCY+CMAC_OUT_RETIMING+CMAC_ACTV_LATENCY)
  val MAC_PD_LATENCY = (CMAC_OUT_RETIMING+CMAC_ACTV_LATENCY-3)     //pd must be 3T earlier than data
  val RT_CMAC_A2CACC_LATENCY = 2
  val RT_CMAC_B2CACC_LATENCY = 3

  val PKT_nvdla_stripe_info_stripe_st_FIELD = 5
  val PKT_nvdla_stripe_info_stripe_end_FIELD = 6
  val PKT_nvdla_stripe_info_layer_end_FIELD = 8

}


class cbufConfiguration extends cmacConfiguration{

  val CBUF_ENTRY_WIDTH = NVDLA_CBUF_ENTRY_WIDTH
  val CBUF_ENTRY_BYTE = CBUF_ENTRY_WIDTH/8
  var CBUF_RAM_DEPTH = NVDLA_CBUF_BANK_DEPTH
  val CBUF_BANK_DEPTH_BITS = NVDLA_CBUF_BANK_DEPTH_LOG2  //log2(bank_depth), how many bits need to give an address in BANK
  val CBUF_RD_DATA_SHIFT_WIDTH =  NVDLA_CBUF_WIDTH_MUL2_LOG2  //log2(ram_width*2),width of data shift
  val CBUF_ADDR_WIDTH  =  NVDLA_CBUF_DEPTH_LOG2       //log2(bank_depth*bank_num)for both read and write
  val CBUF_RD_PORT_WIDTH = NVDLA_CBUF_ENTRY_WIDTH
  val CBUF_WR_PORT_NUMBER = 2   //how many write ports.
  val CSC_IMAGE_MAX_STRIDE_BYTE = 32  //=stride_max*

  var CBUF_BANK_RAM_CASE = 1

  if((NVDLA_CC_ATOMC_DIV_ATOMK==1)& (CBUF_ENTRY_BYTE >= CSC_IMAGE_MAX_STRIDE_BYTE)){
    CBUF_BANK_RAM_CASE = 0
  }
  else if((NVDLA_CC_ATOMC_DIV_ATOMK==1)& (CBUF_ENTRY_BYTE < CSC_IMAGE_MAX_STRIDE_BYTE)){
    CBUF_BANK_RAM_CASE = 1
  }
  else if((NVDLA_CC_ATOMC_DIV_ATOMK==2)& (CBUF_ENTRY_BYTE >= CSC_IMAGE_MAX_STRIDE_BYTE)){
    CBUF_BANK_RAM_CASE = 2
  }
  else if((NVDLA_CC_ATOMC_DIV_ATOMK==2)& (CBUF_ENTRY_BYTE < CSC_IMAGE_MAX_STRIDE_BYTE)){
    CBUF_BANK_RAM_CASE = 3
  }
  else if((NVDLA_CC_ATOMC_DIV_ATOMK==4)& (CBUF_ENTRY_BYTE >= CSC_IMAGE_MAX_STRIDE_BYTE)){
    CBUF_BANK_RAM_CASE = 4
  }
  else if((NVDLA_CC_ATOMC_DIV_ATOMK==4)& (CBUF_ENTRY_BYTE < CSC_IMAGE_MAX_STRIDE_BYTE)){
    CBUF_BANK_RAM_CASE = 5
  }


  //ram case could be 0/1/2/3/4/5  0:1ram/bank; 1:1*2ram/bank; 2:2*1ram/bank; 3:2*2ram/bank  4:4*1ram/bank  5:4*2ram/bank

  var CBUF_RAM_PER_BANK = 1
  var CBUF_WR_BANK_SEL_WIDTH = 1
  var CBUF_RAM_WIDTH = NVDLA_CBUF_ENTRY_WIDTH
  var CBUF_RAM_DEPTH_BITS = 1

  if(CBUF_BANK_RAM_CASE==0){
    CBUF_RAM_PER_BANK = 1
    CBUF_WR_BANK_SEL_WIDTH = 1
    CBUF_RAM_WIDTH = NVDLA_CBUF_ENTRY_WIDTH
    CBUF_RAM_DEPTH = NVDLA_CBUF_BANK_DEPTH
    CBUF_RAM_DEPTH_BITS = CBUF_BANK_DEPTH_BITS
  }
  else if(CBUF_BANK_RAM_CASE==1){
    CBUF_RAM_PER_BANK = 2
    CBUF_WR_BANK_SEL_WIDTH = 1
    CBUF_RAM_WIDTH = NVDLA_CBUF_ENTRY_WIDTH
    CBUF_RAM_DEPTH = NVDLA_CBUF_BANK_DEPTH/2
    CBUF_RAM_DEPTH_BITS = CBUF_BANK_DEPTH_BITS-1
  }
  else if(CBUF_BANK_RAM_CASE==2){
    CBUF_RAM_PER_BANK = 2
    CBUF_WR_BANK_SEL_WIDTH = 2
    CBUF_RAM_WIDTH = NVDLA_CBUF_ENTRY_WIDTH/2
    CBUF_RAM_DEPTH = NVDLA_CBUF_BANK_DEPTH
    CBUF_RAM_DEPTH_BITS = CBUF_BANK_DEPTH_BITS
  }
  else if(CBUF_BANK_RAM_CASE==3){
    CBUF_RAM_PER_BANK = 4
    CBUF_WR_BANK_SEL_WIDTH = 2
    CBUF_RAM_WIDTH = NVDLA_CBUF_ENTRY_WIDTH/2
    CBUF_RAM_DEPTH = NVDLA_CBUF_BANK_DEPTH/2
    CBUF_RAM_DEPTH_BITS = CBUF_BANK_DEPTH_BITS-1
  }
  else if(CBUF_BANK_RAM_CASE==4){
    CBUF_RAM_PER_BANK = 4
    CBUF_WR_BANK_SEL_WIDTH = 4
    CBUF_RAM_WIDTH = NVDLA_CBUF_ENTRY_WIDTH/4
    CBUF_RAM_DEPTH = NVDLA_CBUF_BANK_DEPTH
    CBUF_RAM_DEPTH_BITS = CBUF_BANK_DEPTH_BITS
  }
  else if(CBUF_BANK_RAM_CASE==5){
    CBUF_RAM_PER_BANK = 8
    CBUF_WR_BANK_SEL_WIDTH = 4
    CBUF_RAM_WIDTH = NVDLA_CBUF_ENTRY_WIDTH/4
    CBUF_RAM_DEPTH = NVDLA_CBUF_BANK_DEPTH/2
    CBUF_RAM_DEPTH_BITS = CBUF_BANK_DEPTH_BITS-1
  }
  val CBUF_WR_PORT_WIDTH = CBUF_RAM_WIDTH

  var CBUF_BANK_SLICE_max = 9
  var CBUF_BANK_SLICE_min = 9

  if(CBUF_BANK_NUMBER == 2){
    if(CBUF_BANK_DEPTH == 512){
      CBUF_BANK_SLICE_max = 9
      CBUF_BANK_SLICE_min = 9
    }
    else if(CBUF_BANK_DEPTH == 256){
      CBUF_BANK_SLICE_max = 8
      CBUF_BANK_SLICE_min = 8
    }
    else if(CBUF_BANK_DEPTH == 128){
      CBUF_BANK_SLICE_max = 7
      CBUF_BANK_SLICE_min = 7
    }
    else if(CBUF_BANK_DEPTH == 64){
      CBUF_BANK_SLICE_max = 6
      CBUF_BANK_SLICE_min = 6
    }
  }
  else if(CBUF_BANK_NUMBER==4){
    if(CBUF_BANK_DEPTH == 512){
      CBUF_BANK_SLICE_max = 10
      CBUF_BANK_SLICE_min = 9
    }
    else if(CBUF_BANK_DEPTH == 256){
      CBUF_BANK_SLICE_max = 9
      CBUF_BANK_SLICE_min = 8
    }
    else if(CBUF_BANK_DEPTH == 128){
      CBUF_BANK_SLICE_max = 8
      CBUF_BANK_SLICE_min = 7
    }
    else if(CBUF_BANK_DEPTH == 64){
      CBUF_BANK_SLICE_max = 7
      CBUF_BANK_SLICE_min = 6
    }
  }
  else if(CBUF_BANK_NUMBER==8){
    if(CBUF_BANK_DEPTH == 512){
      CBUF_BANK_SLICE_max = 11
      CBUF_BANK_SLICE_min = 9
    }
    else if(CBUF_BANK_DEPTH == 256){
      CBUF_BANK_SLICE_max = 10
      CBUF_BANK_SLICE_min = 8
    }
    else if(CBUF_BANK_DEPTH == 128){
      CBUF_BANK_SLICE_max = 9
      CBUF_BANK_SLICE_min = 7
    }
    else if(CBUF_BANK_DEPTH == 64){
      CBUF_BANK_SLICE_max = 8
      CBUF_BANK_SLICE_min = 6
    }
  }
  else if(CBUF_BANK_NUMBER==16){
    if(CBUF_BANK_DEPTH == 512){
      CBUF_BANK_SLICE_max = 12
      CBUF_BANK_SLICE_min = 9
    }
    else if(CBUF_BANK_DEPTH == 256){
      CBUF_BANK_SLICE_max = 11
      CBUF_BANK_SLICE_min = 8
    }
    else if(CBUF_BANK_DEPTH == 128){
      CBUF_BANK_SLICE_max = 10
      CBUF_BANK_SLICE_min = 7
    }
    else if(CBUF_BANK_DEPTH == 64){
      CBUF_BANK_SLICE_max = 9
      CBUF_BANK_SLICE_min = 6
    }
  }
  else if(CBUF_BANK_NUMBER==32){
    if(CBUF_BANK_DEPTH == 512){
      CBUF_BANK_SLICE_max = 13
      CBUF_BANK_SLICE_min = 9
    }
    else if(CBUF_BANK_DEPTH == 256){
      CBUF_BANK_SLICE_max = 12
      CBUF_BANK_SLICE_min = 8
    }
    else if(CBUF_BANK_DEPTH == 128){
      CBUF_BANK_SLICE_max = 11
      CBUF_BANK_SLICE_min = 7
    }
    else if(CBUF_BANK_DEPTH == 64){
      CBUF_BANK_SLICE_max = 10
      CBUF_BANK_SLICE_min = 6
    }
  }
}

class cscConfiguration extends cbufConfiguration{

  val CSC_ATOMC = NVDLA_MAC_ATOMIC_C_SIZE
  val CSC_ATOMK = NVDLA_MAC_ATOMIC_K_SIZE
  val CSC_BPE = NVDLA_BPE
  val CBUF_ENTRY_BITS = NVDLA_CBUF_ENTRY_WIDTH
  val CSC_ATOMK_HF = CSC_ATOMK/2
  val CSC_TWICE_ENTRY_BITS = CBUF_ENTRY_BITS*2         //entry*2
  val CSC_ENTRY_BITS = CBUF_ENTRY_BITS   //entry
  val CSC_HALF_ENTRY_BITS = CBUF_ENTRY_BITS/2          //entry/2
  val CSC_QUAT_ENTRY_BITS = CBUF_ENTRY_BITS/4          //entry/4
  val CSC_3QUAT_ENTRY_BITS = CBUF_ENTRY_BITS*3/4        //entry*3/4
  val CSC_ATOMC_HALF = CSC_ATOMC/2           //atomC/2
  val CSC_ATOMC_QUAT = CSC_ATOMC/4           //atomC/4
  val LOG2_ATOMC = NVDLA_MAC_ATOMIC_C_SIZE_LOG2           //log2(atomC)
  val LOG2_ATOMK = NVDLA_MAC_ATOMIC_K_SIZE_LOG2            //log2(atomK)
  val LOG2_CBUF_BANK_DEPTH = NVDLA_CBUF_BANK_DEPTH_LOG2              //log2(bank_depth)
  val LOG2_BANK_NUM = NVDLA_CBUF_BANK_NUMBER_LOG2            //log2(bank_num)
  val NVDLA_VMOD_CBUF_WRITE_LATENCY = 3
  val NVDLA_VMOD_CBUF_READ_LATENCY = 6
  val NVDLA_HLS_CSC_PRA_LATENCY = 5
  val NVDLA_CBUF_READ_LATENCY = NVDLA_VMOD_CBUF_READ_LATENCY
  val NVDLA_MACCELL_NUMBER = CSC_ATOMK
  val CSC_DL_PRA_LATENCY = NVDLA_HLS_CSC_PRA_LATENCY
  val CSC_WL_LATENCY = 4
  val RT_CSC2CMAC_A_LATENCY = 2
  val RT_CSC2CMAC_B_LATENCY = 1
  val CSC_ENTRIES_NUM_WIDTH = 15

  var CSC_WL_PIPELINE_ADDITION = 0
  var CSC_DL_PIPELINE_ADDITION = 0

  if(CSC_WL_LATENCY >= CSC_DL_PRA_LATENCY){
    CSC_DL_PIPELINE_ADDITION = CSC_WL_LATENCY-CSC_DL_PRA_LATENCY
    CSC_WL_PIPELINE_ADDITION = 0
  }
  else{
    CSC_DL_PIPELINE_ADDITION = 0
    CSC_WL_PIPELINE_ADDITION = CSC_DL_PRA_LATENCY-CSC_WL_LATENCY
  }
  val CSC_SG_DONE_FLUSH = "h30"
  val CSC_SG_PEND_FLUSH = "h20"

  //entry bits
  var CSC_WMB_ELEMENTS = "h200"
  //atomC
  var CSC_WT_ELEMENTS = "h40"
  //in bytes, entry/8
  var CSC_ENTRY_HEX = "h40"
  //CSC_ENTRY_HEX/2
  var CSC_HALF_ENTRY_HEX = "h20"
  //CSC_ENTRY_HEX/4
  var CSC_QUAT_ENTRY_HEX = "h10"
  //CSC_ENTRY_HEX-1
  var CSC_ENTRY_MINUS1_HEX = "h3f"
  var CSC_ENTRY_HEX_MUL2 = "h80"

  var CSC_ATOMC_HEX  = "h40"


  if(NVDLA_MAC_ATOMIC_C_SIZE==64){
    //entry bits
    CSC_WMB_ELEMENTS = "h200"
    //atomC
    CSC_WT_ELEMENTS = "h40"
    //in bytes, entry/8
    CSC_ENTRY_HEX = "h40"
    //CSC_ENTRY_HEX/2
    CSC_HALF_ENTRY_HEX  = "h20"
    //CSC_ENTRY_HEX/4
    CSC_QUAT_ENTRY_HEX = "h10"
    //CSC_ENTRY_HEX-1
    CSC_ENTRY_MINUS1_HEX = "h3f"
    CSC_ENTRY_HEX_MUL2 = "h80"

    CSC_ATOMC_HEX = "h40"
  }
  else if(NVDLA_MAC_ATOMIC_C_SIZE==32){
    //entry bits
    CSC_WMB_ELEMENTS = "h100"
    //atomC
    CSC_WT_ELEMENTS = "h20"
    //in bytes, entry/8
    CSC_ENTRY_HEX = "h20"
    //CSC_ENTRY_HEX/2
    CSC_HALF_ENTRY_HEX  = "h10"
    //CSC_ENTRY_HEX/4
    CSC_QUAT_ENTRY_HEX = "h8"
    //CSC_ENTRY_HEX-1
    CSC_ENTRY_MINUS1_HEX = "h1f"
    CSC_ENTRY_HEX_MUL2 = "h40"

    CSC_ATOMC_HEX = "h20"

  }
  else if(NVDLA_MAC_ATOMIC_C_SIZE==8){
    //entry bits
    CSC_WMB_ELEMENTS = "h40"
    //atomC
    CSC_WT_ELEMENTS = "h8"
    //in bytes, entry/8
    CSC_ENTRY_HEX = "h08"
    //CSC_ENTRY_HEX/2
    CSC_HALF_ENTRY_HEX  = "h04"
    //CSC_ENTRY_HEX/4
    CSC_QUAT_ENTRY_HEX = "h2"
    //CSC_ENTRY_HEX-1
    CSC_ENTRY_MINUS1_HEX = "h07"
    CSC_ENTRY_HEX_MUL2 = "h10"

    CSC_ATOMC_HEX = "h08"

  }

  //atomK
  var CSC_MIN_STRIPE = "d32"
  //atomK
  var CSC_ATOMK_HEX = "h20"
  //atomK*2
  var CSC_ATOMK_MUL2_HEX  = "h40"
  //atomK*4
  var CSC_ATOMK_MUL4_HEX = "h40"

  if(NVDLA_MAC_ATOMIC_K_SIZE==32){
    //atomK
    CSC_MIN_STRIPE = "d32"
    //atomK
    CSC_ATOMK_HEX = "h20"
    //atomK*2
    CSC_ATOMK_MUL2_HEX  = "h40"
  }
  else if(NVDLA_MAC_ATOMIC_K_SIZE==16){
    //atomK
    CSC_MIN_STRIPE = "d16"
    //atomK
    CSC_ATOMK_HEX = "h10"
    //atomK*2
    CSC_ATOMK_MUL2_HEX  = "h20"
    //atomK*4
    CSC_ATOMK_MUL4_HEX = "h40"
  }
  else if(NVDLA_MAC_ATOMIC_K_SIZE==8){
    //atomK
    CSC_MIN_STRIPE = "d8"
    //atomK
    CSC_ATOMK_HEX = "h8"
    //atomK*2
    CSC_ATOMK_MUL2_HEX  = "h10"
    //atomK*4
    CSC_ATOMK_MUL4_HEX = "h20"
  }

  //notice, for image case, first atom OP within one strip OP must fetch from entry align place, in the middle of an entry is not supported.
  //thus, when atomC/atomK=4, stripe=4*atomK, feature data still keeps atomK*2

  var CSC_IMG_STRIPE = CSC_ATOMK_MUL2_HEX
  var NVDLA_CC_CREDIT_SIZE = CSC_ATOMK*2

  if(NVDLA_CC_ATOMC_DIV_ATOMK==1){
    CSC_IMG_STRIPE = CSC_ATOMK_MUL2_HEX
    NVDLA_CC_CREDIT_SIZE = CSC_ATOMK*2
  }
  else if(NVDLA_CC_ATOMC_DIV_ATOMK==2){
    CSC_IMG_STRIPE = CSC_ATOMK_MUL2_HEX
    NVDLA_CC_CREDIT_SIZE = CSC_ATOMK*2
  }
  else if(NVDLA_CC_ATOMC_DIV_ATOMK==4){
    CSC_IMG_STRIPE = CSC_ATOMK_MUL4_HEX
    NVDLA_CC_CREDIT_SIZE = CSC_ATOMK*4
  }

  //batch keep 1
  val CSC_BATCH_STRIPE = "h1"

}

class caccConfiguration extends cscConfiguration {
  val CACC_PARSUM_WIDTH = 34 //sum result width for one layer operation.
  val CACC_FINAL_WIDTH = 32 //sum result width for one layer operation with saturaton.
  val CACC_IN_WIDTH = NVDLA_MAC_RESULT_WIDTH //16+log2(atomC),sum result width for one atomic operation.
  val SDP_MAX_THROUGHPUT = NVDLA_SDP_MAX_THROUGHPUT //2^n, no bigger than atomM
  val CACC_ATOMK = NVDLA_MAC_ATOMIC_K_SIZE
  val CACC_ATOMK_LOG2 = NVDLA_MAC_ATOMIC_K_SIZE_LOG2
  val CACC_ABUF_WIDTH = CACC_PARSUM_WIDTH * CACC_ATOMK
  val CACC_DBUF_WIDTH = CACC_FINAL_WIDTH * CACC_ATOMK
  val CACC_SDP_DATA_WIDTH = CACC_FINAL_WIDTH * SDP_MAX_THROUGHPUT
  val CACC_SDP_WIDTH = CACC_SDP_DATA_WIDTH + 2 //cacc to sdp pd width
  val CACC_DWIDTH_DIV_SWIDTH = (CACC_DBUF_WIDTH) / (CACC_SDP_DATA_WIDTH) //1,2,4...
  val CACC_CELL_PARTIAL_LATENCY = 2
  val CACC_CELL_FINAL_LATENCY = 2
  val CACC_D_RAM_WRITE_LATENCY = 1

  var CACC_ABUF_DEPTH = NVDLA_MAC_ATOMIC_K_SIZE * 2 //2*atomK
  var CACC_ABUF_AWIDTH = NVDLA_MAC_ATOMIC_K_SIZE_LOG2 + 1 //log2(abuf_depth)

  if (NVDLA_CC_ATOMC_DIV_ATOMK == 1) {
    CACC_ABUF_DEPTH = NVDLA_MAC_ATOMIC_K_SIZE * 2 //2*atomK
    CACC_ABUF_AWIDTH = NVDLA_MAC_ATOMIC_K_SIZE_LOG2 + 1 //log2(abuf_depth)
  }
  else if (NVDLA_CC_ATOMC_DIV_ATOMK == 2) {
    CACC_ABUF_DEPTH = NVDLA_MAC_ATOMIC_K_SIZE * 2 //2*atomK
    CACC_ABUF_AWIDTH = NVDLA_MAC_ATOMIC_K_SIZE_LOG2 + 1 //log2(abuf_depth)
  }
  else if (NVDLA_CC_ATOMC_DIV_ATOMK == 4) {
    CACC_ABUF_DEPTH = NVDLA_MAC_ATOMIC_K_SIZE * 4 //4*atomK,under image, stripe OP must begin from entry align place
    CACC_ABUF_AWIDTH = NVDLA_MAC_ATOMIC_K_SIZE_LOG2 + 2 //log2(abuf_depth)
  }

  val CACC_DBUF_DEPTH = CACC_ABUF_DEPTH
  val CACC_DBUF_AWIDTH = CACC_ABUF_AWIDTH //address width
}

class cdmaConfiguration extends caccConfiguration{
  val CDMA_CBUF_WR_LATENCY = 3
  val NVDLA_HLS_CDMA_CVT_LATENCY = 3
  val CDMA_SBUF_SDATA_BITS = NVDLA_MEMORY_ATOMIC_SIZE*NVDLA_BPE
  val CDMA_SBUF_DEPTH = 256
  val CDMA_SBUF_NUMBER = 16
  val CDMA_SBUF_RD_LATENCY = 2
  val CDMA_SBUF_WR_LATENCY = 3

  val CDMA_CVT_CELL_LATENCY = NVDLA_HLS_CDMA_CVT_LATENCY
  val CDMA_CVT_LATENCY = CDMA_CVT_CELL_LATENCY + 3
  val CDMA_STATUS_LATENCY = (CDMA_CBUF_WR_LATENCY + CDMA_CVT_LATENCY)

  val SBUF_WINOGRAD = if(NVDLA_WINOGRAD_ENABLE) 1 else 0

  //DorisL-S----------------
  val NVDLA_CDMA_DMAIF_BW = NVDLA_MEMIF_WIDTH
  val NVDLA_CDMA_MEM_MASK_BIT = (NVDLA_MEMIF_WIDTH/NVDLA_BPE/NVDLA_MEMORY_ATOMIC_SIZE)

  val NVDLA_CDMA_MEM_RD_RSP  = ( NVDLA_MEMIF_WIDTH + NVDLA_CDMA_MEM_MASK_BIT )
  val NVDLA_CDMA_MEM_WR_REQ = ( NVDLA_MEMIF_WIDTH + NVDLA_CDMA_MEM_MASK_BIT + 1 )
  val NVDLA_CDMA_MEM_RD_REQ = ( NVDLA_MEM_ADDRESS_WIDTH + 15 )

  val CBUF_WR_BANK_ADDR_BITS  = 9
  val CDMA_GRAIN_MAX_BIT = NVDLA_CDMA_GRAIN_MAX_BIT

  //redpanda3----------------
  val ATMM = NVDLA_MEMORY_ATOMIC_SIZE*NVDLA_BPE
  val ATMMBW = log2Up(NVDLA_MEMORY_ATOMIC_SIZE)
  val ATMKBW = log2Up(NVDLA_MAC_ATOMIC_C_SIZE)
  val DMAIF = NVDLA_MEMIF_WIDTH         // small-64 large-256
  val ATMC = NVDLA_MAC_ATOMIC_C_SIZE*NVDLA_BPE        // small C-8  large C-256  BPE-8
  val ATMM_NUM = DMAIF/ATMM
  val ATMC_NUM = ATMC/ATMM
  val BNUM = NVDLA_MEMIF_WIDTH/NVDLA_BPE
  val MN_BW = NVDLA_MEMIF_WIDTH / NVDLA_BPE * 16
  val SS = log2Up(ATMC/ATMM)
  var KK = log2Up(ATMC/DMAIF)
  if(DMAIF >= ATMC){
    KK = 0
  }
  val ATMM8 = ((8*NVDLA_MEMORY_ATOMIC_SIZE)/NVDLA_MAC_ATOMIC_C_SIZE)
  val CBUF_BANK_SIZE = NVDLA_CBUF_BANK_WIDTH * NVDLA_CBUF_BANK_DEPTH
  val CDMA_ADDR_ALIGN = NVDLA_MEMORY_ATOMIC_SIZE
  val CBUF_BANK_FETCH_BITS = log2Up(CBUF_BANK_SIZE/CDMA_ADDR_ALIGN)
  val BANK_DEPTH_BITS = log2Up(NVDLA_CBUF_BANK_DEPTH) + KK
}


class sdpConfiguration extends cdmaConfiguration
{
  val AM_AW = NVDLA_MEMORY_ATOMIC_LOG2       //atomic m address width
  val AM_AW2 = NVDLA_MEMORY_ATOMIC_LOG2-1
  val AM_DW = NVDLA_MEMORY_ATOMIC_SIZE*8      //atomic m bus width: atomic_m * 1byte
  val AM_DW2 = NVDLA_MEMORY_ATOMIC_SIZE*16    //atomic m bus width: atomic_m * 2byte

  val TW = NVDLA_SDP_EW_THROUGHPUT_LOG2

  val SDP_WR_CMD_DW = NVDLA_MEM_ADDRESS_WIDTH-AM_AW+13

  val BS_OP_DW = 16*NVDLA_SDP_BS_THROUGHPUT
  val BN_OP_DW = 16*NVDLA_SDP_BN_THROUGHPUT
  val EW_OP_DW = 16*NVDLA_SDP_EW_THROUGHPUT
  val EW_OC_DW = 32*NVDLA_SDP_EW_THROUGHPUT

  val BS_IN_DW = 32*NVDLA_SDP_BS_THROUGHPUT
  val BS_OUT_DW = 32*NVDLA_SDP_BS_THROUGHPUT
  val BN_IN_DW = 32*NVDLA_SDP_BN_THROUGHPUT
  val BN_OUT_DW = 32*NVDLA_SDP_BN_THROUGHPUT
  val EW_IN_DW = 32*NVDLA_SDP_EW_THROUGHPUT
  val EW_OUT_DW = 32*NVDLA_SDP_EW_THROUGHPUT

  val EW_CORE_OUT_DW = 32*NVDLA_SDP_EW_THROUGHPUT
  val EW_IDX_OUT_DW = 81*NVDLA_SDP_EW_THROUGHPUT
  val EW_LUT_OUT_DW = 185*NVDLA_SDP_EW_THROUGHPUT
  val EW_INP_OUT_DW = 32*NVDLA_SDP_EW_THROUGHPUT

  val DP_DIN_DW = 32*NVDLA_MEMORY_ATOMIC_SIZE
  val DP_IN_DW = 32*NVDLA_SDP_MAX_THROUGHPUT
  val BS_DOUT_DW = 32*NVDLA_SDP_MAX_THROUGHPUT
  val BN_DIN_DW  = 32*NVDLA_SDP_MAX_THROUGHPUT
  val BN_DOUT_DW  = 32*NVDLA_SDP_MAX_THROUGHPUT
  val EW_DIN_DW  = 32*NVDLA_SDP_MAX_THROUGHPUT
  val EW_DOUT_DW = 32*NVDLA_SDP_MAX_THROUGHPUT
  val CV_IN_DW = 32*NVDLA_SDP_MAX_THROUGHPUT
  val CV_OUT_DW = 16*NVDLA_SDP_MAX_THROUGHPUT
  val DP_OUT_DW = NVDLA_BPE*NVDLA_SDP_MAX_THROUGHPUT
  val DP_DOUT_DW = AM_DW                         //int8: 32 * 1B ; int16: 16 * 2B

  val LUT_TABLE_LE_DEPTH = 65
  val LUT_TABLE_LO_DEPTH = 257
  val LUT_TABLE_MAX_DEPTH = LUT_TABLE_LO_DEPTH

}

class pdpConfiguration extends sdpConfiguration
{
  val NVDLA_PDP_BWPE = NVDLA_BPE
  val NVDLA_PDP_DMAIF_BW = NVDLA_MEMIF_WIDTH

  val SDP_THROUGHPUT = NVDLA_SDP_MAX_THROUGHPUT

  val NVDLA_PDP_ONFLY_INPUT_BW = NVDLA_PDP_BWPE*SDP_THROUGHPUT
  /////////////////////////////////////////////////////////////
  val NVDLA_PDP_MEM_MASK_NUM  = (NVDLA_PDP_DMAIF_BW/NVDLA_PDP_BWPE/NVDLA_MEMORY_ATOMIC_SIZE)
  val NVDLA_PDP_MEM_MASK_BIT = NVDLA_PDP_MEM_MASK_NUM

  val NVDLA_PDP_MEM_RD_RSP = ( NVDLA_PDP_DMAIF_BW + NVDLA_PDP_MEM_MASK_BIT )
  val NVDLA_PDP_MEM_WR_REQ = ( NVDLA_PDP_DMAIF_BW + NVDLA_PDP_MEM_MASK_BIT + 1 )
  val NVDLA_PDP_MEM_RD_REQ = ( NVDLA_MEM_ADDRESS_WIDTH + 15 )

  //redpanda3----------------
  val PDPBW = NVDLA_PDP_THROUGHPUT*NVDLA_PDP_BWPE
  val NVDLA_PDP_UNIT1D_BWPE = NVDLA_PDP_BWPE + 3
  val PDP_UNIT1D_BW = NVDLA_PDP_THROUGHPUT*NVDLA_PDP_UNIT1D_BWPE
  val BATCH_PDP_NUM = ATMM/PDPBW
  val TOTAL_PDP_NUM = NVDLA_PRIMARY_MEMIF_WIDTH/PDPBW    //total fifo num within pdp

  val NVDLA_HLS_ADD17_LATENCY = 4

}

class cdpConfiguration extends pdpConfiguration
{
  val NVDLA_CDP_BWPE = NVDLA_BPE
  val NVDLA_CDP_ICVTO_BWPE = NVDLA_CDP_BWPE+1
  val NVDLA_CDP_DMAIF_BW = NVDLA_MEMIF_WIDTH
  val NVDLA_CDP_MEM_ADDR_BW = NVDLA_MEM_ADDRESS_WIDTH

  val LARGE_FIFO_RAM = true
  val SMALL_FIFO_RAM = false
  //redpanda3
  val CDPBW = NVDLA_CDP_THROUGHPUT*NVDLA_CDP_BWPE
  val CDP_ICVTO_BW = NVDLA_CDP_THROUGHPUT*NVDLA_CDP_ICVTO_BWPE
  val BATCH_CDP_NUM = ATMM/CDPBW
  val TOTAL_CDP_NUM = NVDLA_MEMIF_WIDTH/CDPBW

  val NVDLA_CDP_MEM_MASK_BIT = ATMM_NUM

  val CDP_TPBW = log2Up(NVDLA_CDP_THROUGHPUT)

  val NVDLA_CDP_MEM_RD_RSP = ( NVDLA_CDP_DMAIF_BW + NVDLA_CDP_MEM_MASK_BIT )
  val NVDLA_CDP_MEM_WR_REQ = ( NVDLA_CDP_DMAIF_BW + NVDLA_CDP_MEM_MASK_BIT + 1 )
  val NVDLA_CDP_MEM_RD_REQ = ( NVDLA_MEM_ADDRESS_WIDTH + 15 )

  val pINT8_BW = NVDLA_BPE + 1   //int8 bitwidth after icvt
  val pPP_BW = (pINT8_BW + pINT8_BW) - 1 + 4  //(pINT8_BW * pINT8_BW) -1 is for int8 mode x^2, +4 is after 9 lrn
}

class xxifConfiguration extends cdpConfiguration{

  val FV_RAND_WR_PAUSE = false

  val NVDLA_DMA_RD_IG_PW = NVDLA_MEM_ADDRESS_WIDTH+11
  val NVDLA_DMA_WR_IG_PW = NVDLA_MEM_ADDRESS_WIDTH+13

  val NVDLA_PRIMARY_MEMIF_STRB = NVDLA_MEMORY_ATOMIC_SIZE

  val tieoff_axid_bdma = 0
  val tieoff_axid_sdp = 1
  val tieoff_axid_pdp = 2
  val tieoff_axid_cdp = 3
  val tieoff_axid_rbk = 4
  val tieoff_axid_sdp_b = 5
  val tieoff_axid_sdp_n = 6
  val tieoff_axid_sdp_e = 7
  val tieoff_axid_cdma_dat = 8
  val tieoff_axid_cdma_wt = 9

  var arr_tieoff_axid = List(tieoff_axid_cdma_dat, tieoff_axid_cdma_wt, tieoff_axid_sdp)
  var awr_tieoff_axid = List(tieoff_axid_sdp)

  val RDMA_MAX_NUM = 10
  val WDMA_MAX_NUM = 5

  if(NVDLA_SDP_BS_ENABLE){
    arr_tieoff_axid = arr_tieoff_axid :+ tieoff_axid_sdp_b
  }
  if(NVDLA_SDP_BN_ENABLE){
    arr_tieoff_axid = arr_tieoff_axid :+ tieoff_axid_sdp_n
  }
  if(NVDLA_SDP_EW_ENABLE){
    arr_tieoff_axid = arr_tieoff_axid :+ tieoff_axid_sdp_e
  }
  if(NVDLA_PDP_ENABLE){
    arr_tieoff_axid = arr_tieoff_axid :+ tieoff_axid_pdp
    awr_tieoff_axid = awr_tieoff_axid :+ tieoff_axid_pdp
  }
  if(NVDLA_CDP_ENABLE){
    arr_tieoff_axid = arr_tieoff_axid :+ tieoff_axid_cdp
    awr_tieoff_axid = awr_tieoff_axid :+ tieoff_axid_cdp
  }
  if(NVDLA_RUBIK_ENABLE){
    arr_tieoff_axid = arr_tieoff_axid :+ tieoff_axid_rbk
    awr_tieoff_axid = awr_tieoff_axid :+ tieoff_axid_rbk
  }
  if(NVDLA_BDMA_ENABLE){
    arr_tieoff_axid = arr_tieoff_axid :+ tieoff_axid_bdma
    awr_tieoff_axid = awr_tieoff_axid :+ tieoff_axid_bdma
  }

  val RDMA_NUM = arr_tieoff_axid.length
  val WDMA_NUM = awr_tieoff_axid.length

  var arr_tieoff_lat_fifo_depth = List(0, 0, NVDLA_VMOD_SDP_MRDMA_LATENCY_FIFO_DEPTH)
  if(NVDLA_SDP_BS_ENABLE) {arr_tieoff_lat_fifo_depth = arr_tieoff_lat_fifo_depth :+ NVDLA_VMOD_SDP_BRDMA_LATENCY_FIFO_DEPTH}
  if(NVDLA_SDP_BN_ENABLE) {arr_tieoff_lat_fifo_depth = arr_tieoff_lat_fifo_depth :+ NVDLA_VMOD_SDP_NRDMA_LATENCY_FIFO_DEPTH}
  if(NVDLA_SDP_EW_ENABLE) {arr_tieoff_lat_fifo_depth = arr_tieoff_lat_fifo_depth :+ NVDLA_VMOD_SDP_ERDMA_LATENCY_FIFO_DEPTH}
  if(NVDLA_PDP_ENABLE)    {arr_tieoff_lat_fifo_depth = arr_tieoff_lat_fifo_depth :+ NVDLA_VMOD_PDP_RDMA_LATENCY_FIFO_DEPTH}
  if(NVDLA_CDP_ENABLE)    {arr_tieoff_lat_fifo_depth = arr_tieoff_lat_fifo_depth :+ NVDLA_VMOD_CDP_RDMA_LATENCY_FIFO_DEPTH}
  if(NVDLA_RUBIK_ENABLE)  {arr_tieoff_lat_fifo_depth = arr_tieoff_lat_fifo_depth :+ 256}
  if(NVDLA_BDMA_ENABLE)   {arr_tieoff_lat_fifo_depth = arr_tieoff_lat_fifo_depth :+ 256}

  val MCIF_WRITE_CQ_WIDTH = 3
  val MCIF_WRITE_CQ_VEC_NUM = 5
}


class nvdlaConfig extends xxifConfiguration{

  val NVDLA_DMAIF_BW = NVDLA_MEMIF_WIDTH

  val MULTI_MASK = (NVDLA_DMAIF_BW/NVDLA_BPE/NVDLA_MEMORY_ATOMIC_SIZE)

  val NVDLA_MEM_MASK_BIT = MULTI_MASK

  val NVDLA_MEM_RD_RSP  = ( NVDLA_DMAIF_BW + NVDLA_MEM_MASK_BIT )
  val NVDLA_MEM_WR_REQ  = ( NVDLA_DMAIF_BW + NVDLA_MEM_MASK_BIT + 1 )
  val NVDLA_MEM_RD_REQ  = ( NVDLA_MEM_ADDRESS_WIDTH + 15 )

}
